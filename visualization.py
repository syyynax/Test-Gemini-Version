# This file is responsible for analyzing and visualizing event data, sourced from Google Calender or a local database. 
# Key components of this file:
# - Data transformation: Converts raw event lists into clean pandas df
# - Data aggregation: Calculates event counts per person and per day of the week 
# - Visualization: Generates interactive charts (using Matplotlib/Seaborn within Streamlit)
# - UI Integration: Provides the Streamlit interface for filterint data by date range and toggling between different chart types 

import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt
import seaborn as sns

# Set style for all charts generated by mathplotlib and seaborn (gives a nice dark grid background)
sns.set_theme(style="darkgrid")

def events_to_df(events_list):
    """
    Converts a list of event dictionaries (from Google Calendar or Database) into a pandas DataFrame.
    This is necessary because plotting libraries work best with DataFrames.
    
    Expects dictionary keys: 'start', 'end', 'summary' (or 'title'), and optionally 'person'.
    """
    #Initializes Data Frame from the list of dictionnaries
    df = pd.DataFrame(events_list)
    #Returns an empty Data Frame immediately if no data is present to avoid any errors
    if df.empty:
        return pd.DataFrame()

    # --- Data cleaning and type converion ---
    # Ensure 'start' and 'end' columns are converted to datetime objects 
    if "start" in df.columns:
        df["start"] = pd.to_datetime(df["start"])
    if "end" in df.columns:
        df["end"] = pd.to_datetime(df["end"])

    # --- Feature engineering ---
    # Fallback: Use 'summary' as 'title' if 'title' is missing (Google API often uses 'summary')
    # We ensure a consitent 'title' column exists for plotting labels 
    if "title" not in df.columns and "summary" in df.columns:
        df["title"] = df["summary"]
        
    
    # If 'person' is not explicitly provided, try to extract it from the title.
    # Example: "Mia: Dentist" -> Person is "Mia"
    if "person" not in df.columns:
        df["person"] = df["title"].apply(lambda x: x.split(":")[0] if isinstance(x, str) else "Unknown")
        
    # Calculate the day of the week (e.g., "Monday") for analysis
    if "start" in df.columns:
        df["weekday"] = df["start"].dt.day_name()

    return df

def plot_events_per_person(df):
    """
    Generates a bar chart showing how many events each person has within the currently selected time range.
    """
    if df.empty or "person" not in df.columns:
        st.warning("Not enough data to plot events per person.")
        return

    # Count frequency of each value in the 'person' column 
    counts = df["person"].value_counts()
    
    # Create a mathplotlib figure and axis object for plotting 
    fig, ax = plt.subplots(figsize=(8, 4))
    # Use seaborn barplot for better aesthetics and colors (viridis palette)
    sns.barplot(x=counts.index, y=counts.values, ax=ax, palette="viridis")

    # Set chart labels and title
    ax.set_title("Number of Events by Person (Selected Timeframe)")
    ax.set_ylabel("Events")
    ax.set_xlabel("Person")

    # Rotate x-axis labels to prevent overlap, especially with longer names
    plt.xticks(rotation=45) 

    # Display the mathplot figure in the Streamlit interface 
    st.pyplot(fig) 

def plot_events_per_weekday(df):
    """
    Generates a line chart showing the distribution of events across the week.
    Useful to see which days are busiest.
    """
    if df.empty or "weekday" not in df.columns:
        st.warning("Not enough data to plot events by weekday.")
        return

    # Define the correct order of days (otherwise they might be sorted alphabetically)
    order = ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday", "Sunday"]
    # Convert the 'weekday' column to a categorical type with the specified order. 
    df["weekday"] = pd.Categorical(df["weekday"], categories=order, ordered=True)
    
    # Count events per weekday and sort by the day order defined above
    weekday_counts = df["weekday"].value_counts().sort_index()
    # Create Mathplotlib figure and axis 
    fig, ax = plt.subplots(figsize=(8, 4))
    # Use seaborn's lineplot to show trends across the week. 
    sns.lineplot(x=weekday_counts.index, y=weekday_counts.values, marker="o", ax=ax, sort=False)

    # Set chart labels and title 
    ax.set_title("Events by Weekday (Selected Timeframe)")
    ax.set_ylabel("Events")
    ax.set_xlabel("Weekday")
    
    # Import utility to ensure y-axis ticks are integers (since event counts must be whole numbers)
    from matplotlib.ticker import MaxNLocator
    ax.yaxis.set_major_locator(MaxNLocator(integer=True))

    # Display the Mathplotlib figure in the Streamlit interface. 
    st.pyplot(fig)

def show_visualizations(events_list):
    """
    Main function that sets up the UI, handles user interaction (date, filtering), and calls the plotting functions.
    """
    st.markdown("### How busy is everyone?")

    # --- 1. Data Preparation ---
    df = events_to_df(events_list)

    if df.empty:
        st.info("No data available to visualize.")
        return

    # Determine the full range of dates available in the data
    min_date = df["start"].min().date()
    max_date = df["start"].max().date()

    # --- 2. User Input (Date Filtering) ---
    col1, col2 = st.columns([1, 2])
    
    with col1:
        # Calculate a default end date for a 7-day initial view 
        default_end = min_date + pd.Timedelta(days=7)
        if default_end > max_date: default_end = max_date
        
        # Streamlit date input for filtering the data 
        dates = st.date_input(
            "Filter Time Range",
            value=(min_date, default_end),
            min_value=min_date,
            max_value=max_date
        )

    # Validate Date Input (User must pick both start and end)
    if isinstance(dates, tuple) and len(dates) == 2:
        start_date, end_date = dates
    else:
        st.info("Please select a start and end date.")
        return 
    # Input validation: check for logical date order 
    if start_date > end_date:
        st.error("Start date must be before end date.")
        return
    # --- 3. Interaction Control ---
    # Initialize Session State for chart visibility (toggle button)
    # This prevents the charts from constantly redrawing unless the user hits 'Generate'.
    if "show_plot" not in st.session_state:
        st.session_state.show_plot = False

    # Button to show/refresh charts
    if st.button("Generate / Refresh Charts"):
        st.session_state.show_plot = True

    # --- 4. Chart rendering ---
    # Only proceed to filter and draw charts if the button has been clicked 
    if st.session_state.show_plot:
        st.divider()
        
        # Create a Boolean mask to filter events where the start date falls within the selected range (inclusive)
        mask = (df["start"].dt.date >= start_date) & (df["start"].dt.date <= end_date)
        df_filtered = df[mask]

        if df_filtered.empty:
            st.warning(f"No events found between {start_date} and {end_date}.")
        else:
            # Show user how many events are included in the analysis
            st.caption(f"Showing {len(df_filtered)} events in selected timeframe.")
            
            # Radio button allows users to switch between chart types
            chart_type = st.radio(
                "Select Visualization:",
                ["Events by Person", "Events by Weekday"],
                horizontal=True
            )

            # Conditional rendering of the selected chart 
            if chart_type == "Events by Person":
                plot_events_per_person(df_filtered)
            elif chart_type == "Events by Weekday":
                plot_events_per_weekday(df_filtered)
